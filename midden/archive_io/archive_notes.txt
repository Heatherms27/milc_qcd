Archive I/O

To use the archive format reads and writes,

    reload_serial (previously there) and,
    save_archive

in io_lat5.c, one needs to add the following code to
the lattice.h and setup.c files for an application.


0. Short summary:

Untar io_archive.tar.gz in milc root dir (above generic).
edit lattice.h and setup.c as per below
edit Make_template in app dir and generic to use io_lat5.o
recompile



1. Code changes:

A. Files:

You must use the enclosed:

generic/io_lat5.c
generic/io_helpers.c
libraries/io_lat.h

and of course the Make_template file must compile/use io_lat5.o
in both the generic and application dirs.


B. Edits:

Add this to
======= lattice.h =========================================================
/* --- vars for archive storage ------------------------------------------ */
EXTERN  char ensemble_label[128];
EXTERN  char ensemble_id[32]; 
EXTERN  int sequence_number; 
===========================================================================

In setup.c, within the function initial_set(), perhaps after printing
the banner, add the following strcpy line:
=== setup.c ======
in initial_set() {
===========================================================================
/* --- Label for the ensemble of lattices using this lattice.h ----------- */
        strcpy(ensemble_label,"SU3 with improved KS action");
===========================================================================
or whatever your lattice is about.

Archive lattices are stored with an ascii header attached to the top
of the file and the above variables store required header fields.

* ensemble_lable: is a one line description of the whole ensemble.
                  this might apply to a series of beta's, masses,
                  smearings, etc.
                  Examples: "Microcanonical simulation with refreshing"
                    or      "SU3 with improved KS action"


* ensemble_id: is a short string used as a directory name for a
              uniform subset of ensemble (ie. one beta, one mass,
              etc.) at the archive. 
	      Examples: FT2412B5725M01

	      Note that this is usually incorporated into the archive
              filename:

	      dir 2412B5725M01:
		    u_MILC_2412B5725M01.00
		    u_MILC_2412B5725M01.10
		    u_MILC_2412B5725M01.20
	      

* sequence_number: (an int) is the number of this lattice in the
                   sequence. It is usually the trailing .10 
                   part of the filename.

  
Filenames for MILC lattices at the archive are of the form
u_MILC_2412B5725M01.00
         ^          ^------- sequence_number
         |___ ensemble_id



2. Reading and writing

The call "reload_serial" in the input file recognizes new and old
formats; it now will also automatically detect archive lattices upon
reading. I haven't done anything with the parallel read/writes for
archive files as yet (not sure that makes sense).

A. Reading archive files.

Reloading an archive in is trivial. Just put

  reload_serial filename

in the input file and the function will identify the lattice.  At
present the read_gauge_hdr() [in io_lat5.c] function prints the ascii
lattice header to stdout during the read.


B. Writing archive files.

This is accomplished via

  save_archive  filename  ensemble_id  sequence_number

in the input file. Note that the three arguments are required.
Save_archive writes an archive formated lattice: header + x-y-z-t
ordered short links. A short link is the first two rows of the SU(3)
matrix. During read, the third row is reconstructed from unitarity.

The second argument, ensemble_id, is a short string that labels
the ensemble subset (as in 2412B5725M01 above). 

The third argument, sequence_number, is the number in the sequence of
generated lattices. It is an integer.

Example: 

  save_archive  u_MILC_2412B5725M01.20 2412B5725M01 20

will save the lattice in a form ready to be ftp'ed to NERSC for
storage.

C. Info file data.

When writing the archive header, the w_serial will process the
gauge_info file and call write_appl_gauge_info() in gauge_info.c
The output of write_appl_gauge_info() goes into the attached
header file of the lattice. The then header looks like this,
with what would be the milc info file between the MILC_INFO
lines:

BEGIN_HEADER
DATATYPE = 4D_SU3_GAUGE
DIMENSION_1 = 8
DIMENSION_2 = 8
DIMENSION_3 = 8
DIMENSION_4 = 4
CHECKSUM = c623a989
LINK_TRACE = 0.8753106594
PLAQUETTE = 0.7026698589
ENSEMBLE_LABEL = Unspecified SU3 MILC Lattice
ENSEMBLE_ID = WTEST
SEQUENCE_NUMBER = 0
MILC_INFO = -------BEGIN-------
magic_number = 20103
time_stamp = "Thu Apr 13 18:15:32 2000"
checksums = "0 0"
nx = 8
ny = 8
nz = 8
nt = 4
action.description = "Pure gauge"
gauge.description = "One plaquette gauge action."
gauge.beta11 = 6.000000
MILC_INFO = --------END--------
END_HEADER
data....

I have changed write_gauge_info_item() [io_lat5.c] to insert
an '=' between keywords and their values when writing. This is
needed to match archive header format and prevent the crash
of chklat.c. So an info file will have 
magic_number = 20103
time_stamp = "Thu Apr 13 18:15:32 2000"
etc.

Also, at the moment I have not worked to make the archive checksum and
milc checksum consistent. Thus during save_archive, we don't compute
the milc checksum, only the archve checksum.


Cheers,

      --Jim
